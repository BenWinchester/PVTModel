#!/usr/bin/python3
"""
Does some analysis.

"""

import logging
import os

from typing import Any, List, Dict, Optional, Tuple

import json
import re

from matplotlib import pyplot as plt

from __utils__ import get_logger

# The directory in which old figures are saved
OLD_FIGURES_DIRECTORY = "old_figures"
# How many values there should be between each tick on the x-axis
X_TICK_SEPARATION = 4

# The first day to include in the output graph.
FIRST_DAY: int = 28
# The number of days to include in the output graph.
NUM_DAYS_TO_PLOT: int = 1
# The number of days that the model was run for
NUM_DAYS_MODEL_RUN_FOR: int = 30
# Whether to average the model_data.
AVERAGE: bool = False
# The number of steps per day
STEPS_PER_DAY = 48
# The resolution of the model that was run, measured in minutes
RESOLUTION = 30


def load_model_data(filename: str) -> Dict[Any, Any]:
    """
    Loads some model_data that was generated by the model.

    :param filename:
        The name of the model_data file to open.

    :return:
        The JSON model_data, loaded as a `dict`.

    """

    with open(filename) as f:
        return json.load(f)


def plot(
    label: str,
    y_label: str,
    resolution: float,
    model_data: Dict[Any, Any],
    hold=False,
    axes=None,
    shape: str = "x",
    colour: str = None,
) -> Optional[Any]:
    """
    Plots some model_data based on input parameters.

    :param label:
        The name of the model_data label to plot. For example, this could be "pv_temperature",
        in which case, the pv temperature would be plotted at the tine steps specified
        in the model.

    :param y_label:
        The label to assign to the y axis when plotting.

    :param resolution:
        The resolution of the model that was run. This is measured in minutes.

    :param model_data:
        The model_data, loaded from the model's output file.

    :param hold:
        Whether to hold the screen between plots (True) or reset it (False).

    :param axes:
        If provided, a separate axis is used for plotting the model_data.

    :param shape:
        This sets the shape of the marker for `matplotlib.pyplot` to use when plotting
        the model_data.

    :param colour:
        The colour to use for the plot.

    """

    # If we are not averaging the model_data, then we simply plot the model_data running from the
    # first day to plot to the last day to plot.
    if not AVERAGE:
        try:
            x_model_data, y_model_data = (
                list(
                    list(model_data.keys())[
                        (FIRST_DAY * STEPS_PER_DAY) : (FIRST_DAY + NUM_DAYS_TO_PLOT)
                        * STEPS_PER_DAY
                    ]
                ),
                list([value[label] for value in model_data.values()])[
                    (FIRST_DAY * STEPS_PER_DAY) : (FIRST_DAY + NUM_DAYS_TO_PLOT)
                    * STEPS_PER_DAY
                ],
            )
        except KeyError as e:
            logger.error(
                "The label %s could not be found in the data. See log for details.",
                label,
            )
            logger.debug(str(e))
            return None

    # If the model_data is being averaged, then we take an average over the selection
    # specified.
    else:
        # Extract all model_data
        try:
            x_model_data, y_raw = (
                list(model_data.keys()),
                list([value[label] for value in model_data.values()]),
            )
        except KeyError as e:
            logger.error(
                "The label %s could not be found in the data. See log for details.",
                label,
            )
            logger.debug(str(e))
            return None

        # Construct averages
        x_model_data = x_model_data[:STEPS_PER_DAY]
        y_model_data: list() = []
        for _ in range(STEPS_PER_DAY):
            y_model_data.append(sum(y_raw[::STEPS_PER_DAY]) / NUM_DAYS_MODEL_RUN_FOR)
            y_raw.pop(0)

    # If we are not holding the graph, then clear the model_data.
    if not hold:
        plt.clf()

    # Reduce the values on the x axis to be times.
    # x_model_data = [float(item) / (resolution / 60) for item in x_model_data]

    # If we are not using axes, then the model_data can be straight plotted...
    if axes is None:
        plt.scatter(x_model_data, y_model_data, label=label, marker=shape)
        (line,) = plt.plot(x_model_data, y_model_data, label=label, marker=shape)

    # ... otherwise, the model_data needs to be plotted on just on axis.
    else:
        axes.scatter(x_model_data, y_model_data, label=label, marker=shape)
        if colour is None:
            (line,) = axes.plot(x_model_data, y_model_data, label=label, marker=shape)
        else:
            (line,) = axes.plot(
                x_model_data, y_model_data, label=label, marker=shape, color=colour
            )

    # Set the labels for the axes.
    plt.xlabel("Time / Resolution Steps From Model Start")
    plt.ylabel(y_label)

    return line


def save_figure(figure_name: str) -> None:
    """
    Saves the figure, shuffling existing files out of the way.

    :param figure_name:
        The name of the figure to save.

    """

    # Create a regex for cycling through the files.
    file_regex = re.compile("figure_{}_(?P<old_index>[0-9]).jpg".format(figure_name))

    # We need to work download from large numbers to new numbers.
    filenames = sorted(os.listdir(OLD_FIGURES_DIRECTORY))
    filenames.reverse()

    # import pdb

    # pdb.set_trace()

    # Incriment all files in the old_figures directory.
    for filename in filenames:
        file_match = re.match(file_regex, filename)
        if file_match is None:
            continue
        new_file_name = re.sub(
            str(file_match.group("old_index")),
            str(int(file_match.group("old_index")) + 1),
            filename,
        )
        os.rename(
            os.path.join(OLD_FIGURES_DIRECTORY, filename),
            os.path.join(OLD_FIGURES_DIRECTORY, new_file_name),
        )

    # Move the current _1 file into the old directory
    if os.path.isfile(f"figure_{figure_name}_1.jpg"):
        os.rename(
            f"figure_{figure_name}_1.jpg",
            os.path.join(OLD_FIGURES_DIRECTORY, f"figure_{figure_name}_1.jpg"),
        )

    # If it exists, move the current figure to _1
    if os.path.isfile(f"figure_{figure_name}.jpg"):
        os.rename(f"figure_{figure_name}.jpg", f"figure_{figure_name}_1.jpg")

    # Save the figure
    plt.savefig(f"figure_{figure_name}.jpg")


def plot_figure(
    figure_name: str,
    model_data: Dict[Any, Any],
    first_axis_things_to_plot: List[str],
    first_axis_label: str,
    *,
    first_axis_y_limits: Optional[Tuple[int, int]] = None,
    second_axis_things_to_plot: Optional[List[str]] = None,
    second_axis_label: Optional[str] = None,
    second_axis_y_limits: Optional[Tuple[int, int]] = None,
) -> None:
    """
    Does all the work needed to plot a figure with up to two axes and save it.

    :param figure_name:
        The name to assign to the figure when saving it.

    :param model_data:
        The model_data, as extracted from the JSON outputted by the simulation.

    :param first_axis_things_to_plot:
        The list of variable names (keys in the JSON model_data) to plot on the first axis.

    :param first_axis_label:
        The label to assign to the first y-axis.

    :param first_axis_y_limits:
        A `tuple` giving the lower and upper limits to set for the y axis for the first
        axis.

    :param second_axis_things_to_plot:
        The list of variable names (keys in the JSON model_data) to plot on the second axis.

    :param second_axis_label:
        The label to assign to the second y-axis.

    :param second_axis_y_limits:
        A `tuple` giving the lower and upper limits to set for the y axis for the second
        axis.

    """

    # Generate the necessary local variables needed for sub-plotting.
    fig, ax1 = plt.subplots()

    lines = [
        plot(
            entry,
            first_axis_label,
            RESOLUTION,
            model_data,
            hold=True,
            axes=ax1,
        )
        for entry in first_axis_things_to_plot
    ]

    ax1.set_xticks(ax1.get_xticks()[::X_TICK_SEPARATION])

    # Set the y limits if appropriate
    if first_axis_y_limits is not None:
        plt.ylim(*first_axis_y_limits)

    # Save the figure and return if only one axis is plotted.
    if second_axis_things_to_plot is None:
        plt.legend(lines, first_axis_things_to_plot)  # , loc="upper left")
        save_figure(figure_name)
        return

    # Second-axis plotting.
    ax2 = ax1.twinx()

    lines.extend(
        [
            plot(
                entry,
                second_axis_label,
                RESOLUTION,
                model_data,
                hold=True,
                axes=ax2,
                shape=".",
            )
            for entry in second_axis_things_to_plot
        ]
    )

    plt.legend(lines, first_axis_things_to_plot + second_axis_things_to_plot)

    ax2.set_xticks(ax2.get_xticks()[::X_TICK_SEPARATION])

    # Set the y limits if appropriate.
    if second_axis_y_limits is not None:
        plt.ylim(*second_axis_y_limits)

    save_figure(figure_name)


if __name__ == "__main__":

    # * Set up the logger
    logger = get_logger("pvt_analysis")

    # * Extract the data.
    data = load_model_data("data_output.json")

    # * Plotting all tank-related temperatures
    plot_figure(
        "tank_temperature",
        data,
        [
            "collector_temperature",
            "collector_output_temperature",
            "collector_temperature_gain",
            "tank_temperature",
            "tank_output_temperature",
            "ambient_temperature",
            "sky_temperature",
        ],
        "Temperature / degC",
    )

    # * Plotting all temperatures relevant in the system.
    plot_figure(
        "all_temperatures",
        data,
        [
            "collector_temperature",
            "collector_output_temperature",
            "collector_temperature_gain",
            "tank_temperature",
            "tank_output_temperature",
            "ambient_temperature",
            "sky_temperature",
            "glass_temperature",
            "pv_temperature",
        ],
        "Temperature / degC",
    )

    # * Plotting all PV-T panel layer temperatures
    plot_figure(
        "pvt_panel_temperature",
        data,
        [
            "glass_temperature",
            "pv_temperature",
            "collector_temperature",
            "ambient_temperature",
            "sky_temperature",
        ],
        "Temperature / degC",
    )

    # * Plotting all temperatures in an unglazed panel
    plot_figure(
        "unglazed_pvt_temperature",
        data,
        [
            "pv_temperature",
            "collector_temperature",
            "ambient_temperature",
            "sky_temperature",
        ],
        "Temperature / degC",
    )

    # * Plotting thermal-collector-only temperatures
    plot_figure(
        "isolated_thermal_collector",
        data,
        [
            "collector_temperature",
            "ambient_temperature",
            "sky_temperature",
        ],
        "Temperature / degC",
    )

    # * Plotting demand covered and thermal load on one graph
    plot_figure(
        "demand_covered",
        data,
        first_axis_things_to_plot=["dc_electrical", "dc_thermal"],
        first_axis_label="Demand Covered / %",
        first_axis_y_limits=(0, 100),
        second_axis_things_to_plot=["thermal_load", "thermal_output"],
        second_axis_label="Thermal Power / Watts",
    )

    # * Plotting the solar irradiance and irradiance normal to the panel
    plot_figure(
        "solar_irradiance",
        data,
        ["solar_irradiance", "normal_irradiance"],
        "Solar Irradiance / Watts / meter squared",
    )

    # * Plotting the auxiliary heating required along with the thermal load on the
    # * system.

    plot_figure(
        "auxiliary_heating",
        data,
        first_axis_things_to_plot=["auxiliary_heating", "tank_heat_addition"],
        first_axis_label="Auxiliary Heating and Tank Heat Addition / Watts",
        second_axis_things_to_plot=["thermal_load", "thermal_output"],
        second_axis_label="Thermal Power / Watts",
    )

    # * Plotting Maria's figure 8A - Electrical Power and Net Electrical Power
    plot_figure(
        "electrical_output_8A",
        data,
        ["gross_electrical_output", "net_electrical_output"],
        "Electrical Power Output / W",
    )

    # * Plotting Maria's figure 10 - Electrical Power
    plot_figure(
        "gross_electrical_output_10",
        data,
        ["gross_electrical_output"],
        "Electrical Power Output / W",
    )

    # * Plotting Maria's figure 8B - Thermal Power Supplied and Thermal Power Demanded
    plot_figure(
        "thermal_output_8B",
        data,
        ["thermal_load", "thermal_output"],
        "Thermal Power Output / W",
    )

    # * Plotting the collector input, output, gain, and temperature.
    plot_figure(
        "collector_temperatures",
        data,
        [
            "collector_temperature",
            "collector_output_temperature",
            "collector_input_temperature",
            "collector_temperature_gain",
            "tank_temperature",
        ],
        "Temperature / K",
    )
